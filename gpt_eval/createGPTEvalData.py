
import os
import openai
import json
import pickle
import time
import random
import re

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--inputfile", dest="inputfile")
parser.add_argument("--outputfile", dest="outputfile")
args = parser.parse_args()

random.seed(42)
#put your OPENAI credentials here:
openai.organization = ""
openai.api_key = ""
openai.Model.list()

def getReformulations_noHistory(question):
    """
    Answer the question using GPT.
    Returns the plain string as generated by the GPT model.
    """ 
    while True:
        try:
            response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": "Reformulate the 'Question' 10 times in a short, informal way. Assume third person singular if not obvious from the question.\n 'Question': " + question + "\n 'Reformulation': "},
                ],
                temperature=0.0,
            
            )   
            gpt_refs = response.choices[0].message.content
            break
        except:
            #print(f"FAIL: GPT did not respond to the prompt for question {question}")
            time.sleep(10)

    return gpt_refs


def getReformulations_withHistory(conversation_history, question):
    """
    Answer the question using GPT.
    Returns the plain string as generated by the GPT model.
    """
    #, complete the question with information from the conversation history;\n 'History':" + conversation_history + 
    while True:
        try:
            response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": "Reformulate the 'Question' 5 times in a short, informal way. Enumerate the reformulations. Assume third person singular if not obvious from the question.\n 'History': " + conversation_history + "\n 'Question': " + question + "\n 'Reformulation': "},
                ],
                temperature=0.0,
            
            )
            
            gpt_refs = response.choices[0].message.content
            #print("gpt refs: ", gpt_refs)
            break
        except:
            #print(f"FAIL: GPT did not respond to the prompt for question {question}")
            time.sleep(10)

    return gpt_refs



if __name__ == "__main__":


    with open(args.inputfile, "rb") as inFile:
        test_data = pickle.load(inFile)

    new_data = dict()
    for qId in test_data.keys():
        new_data[qId] = test_data[qId]
        convId = qId.split("-")[0] + "-" + qId.split("-")[1]
        print("history: ", test_data[qId]['conv_history'], " original question: ", test_data[qId]['question'])
        refs = getReformulations_withHistory(test_data[qId]['conv_history'], test_data[qId]['question'])
        i = 0
        for ref in refs.split("\n"):
            i += 1
            newId = convId + "-" + str(i) + "-0"
            new_data[newId] = dict()
            if re.match('^[0-9]. $', ref[:3]):
                new_data[newId]["question"] = ref[3:]
            else:
                new_data[newId]["question"] = ref
            new_data[newId]["answers"] = test_data[qId]["answers"]
            new_data[newId]["conv_history"] = test_data[qId]["conv_history"]
            
            print("newId: ", newId, "ref: " ,new_data[newId]["question"])
        print("--------------------------------", flush=True)

    with open(args.outputfile, "wb") as outFile:
        pickle.dump(new_data, outFile)